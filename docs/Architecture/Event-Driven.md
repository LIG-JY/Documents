# Event Driven Architecture

기존의 프로그래밍 스타일은 질문이나 명령을 던지고 응답을 기다리는 방식이다. 절차적, 개체지향 프로그래밍은 기존의 스타일을 사용한다. 이런 프로그래밍이 익숙한 이유는 데이터베이스를 바탕으로 소프트웨어 시스템을 설계해왔기 때문이다.

이벤트 스트리밍 체계는 데이터를 데이터베이스에 담아두지 않고 메세지 형태로 계속 흘린다.

## Event

이벤트의 content는 value에 보관하고, Key를 통해 이벤트를 식별, 집계, 라우팅을 수행한다. 여기서 키는 필수가 아니다.  
책에서 정의하는 이벤트 구조는 3가지다.

- 키 없는 이벤트
- 엔티티 이벤트
- 키 있는 이벤트

- 이벤트는 그 자체로 장기 데이터 보관소 역할을 하게 된다. 특히 키가 있는 이벤트는 테이블-스트림 이원성을 보장한다.  
  - MySQL의 binlog와 같은 append-only file처럼 immutable log에 대한 이벤트를 생산할 수 있다. 이 로그를 재생하면 테이블과 테이블 내부의 데이터를 정확하게 되살릴 수 있다.

### 이벤트 상태 저장

이벤트 스트림을 구체화해서 현재 상태를 나타낼 수 있어야한다.

> 비즈니스 로직을 처리하기 위해 상태를 유지하는 것은 이벤트 기반 아키텍처에서 지극히 일반적인 패턴입니다. 여러분의 전체 비즈니스 모델이 순수하게 상태를 저장하지 않는 스트리밍 도메인에 꼭 맞을 가능성은 거의 없습니다.

### Event Broker vs 메시지 브로커

이벤트 브로커는 메시지 브로커 대신 쓸 수 있지만, 메시지 브로커는 이벤트 브로커의 기능을 완전히 대체할 수 없다.

- 메시지 브로커를 이용하면 발행/구독 메시지 큐를 통해 네트워크 전체를 통신할 수 있다. 이 때 프로듀서가 큐에 메시지를쓰면 컨슈머는 메시지를 받아 처리하고 메시지가 소비된 것으로 ACK되면 메시지는 짧은 시간 내에 삭제된다.

- 이벤트 브로커는 메시지 브로커와 다른 종류의 문제를 처리하고자 설계됬다. 이벤트 브로커는 순서대로 쌓은 사실 로그를 제공할 목적으로 설계되었다.
  - 메시지 브로커에서 메시지는 큐 단위로 처리되기 때문에 여러 컨슈머가 같은 큐를 소비하면 각자 레코드의 subset만 받을 수 있다. 따라서 각 컨슈머는 모든 이벤트의 전체 사본을 얻을 수 없다. 반면 이벤트 브로커는 레코드 장부를 딱 하나만 보관하고 인덱스를 통해 개별 엑세스를 관리하기 때문에 독립적인 여러 컨슈머가 각자 필요한 이벤트에 접근할 수 있다.

  - 메시지 브로커는 ACK을 받고 이벤트를 바로 삭제하지만 이벤트 브로커는 이벤트를 보존한다.

#### 불변 로그에서 소비

일반적으로 이벤트 브로커는 append-only immutable log를 사용한다. 이벤트는 로그 끝에 추가되고, auto-increment index ID가 부여된다. 컨슈머는 이 인덱스 ID가 가리키는 위치부터 접근해서 비즈니스 요건 및 이벤트 브로커에서 사용 가능한 제약에 따라 이벤트 스트림이나 큐로 이벤트를 소비한다.

##### 이벤트 스트림으로 소비

각 컨슈머는 이벤트 스트림에서 이전에 읽은 인덱스를 가리키는 자신만의 위치를 알아서 업데이트 한다.

인덱스는 이벤트 스트림의 처음부터 몇 번째인지 나타내는 offset이다.

##### 큐로 소비

큐로 소비할 경우 이벤트 브로커는 소비가 끝난 이벤트를 consumed 표시하고 다른 컨슈머들에게 제공하지 않는다.

큐에서 받은 이벤트는 순서가 보장되지 않는다.

### 이벤트 설계

이벤트 안티 패턴을 피하자

#### 오직 진실만을 말할지어다

잘 정의된 이벤트는 단순히 뭔가 일어났음을 전하는 메시지가 아니라 그 이벤트가 발생한 동안 모든 일들을 빠짐없이 기술한다.

#### 스트림당 이벤트 정의는 하나만 사용

종류가 다른 이벤트들을 이벤트 스트림에 섞어 놓으면 안티패턴

#### 가장 좁은 범위의 데이터 타입 사용

프로그래밍 언어의 타입 체크 기능, 직렬화 유닛 테스트에 유리하도록 이벤트 데이터 타입은 가장 범위가 좁은 것을 사용하자.

- 문자열을 이용해 숫자 값을 저장 → 안티패턴
  - 컨슈머가 문자열을 파싱해서 숫자 값으로 변환할 때 전반적으로 오류가 날 가능성이 있다.
- 정수를 불리언으로 사용
  - 0, 1 대신 불리언 쓰자
- 문자열을 ENUM으로 사용
  - 프로듀서는 자신이 발행한 값이 컨슈머가 수용 가능한 pseudo-enum 리스트에 있음을 보장해야하기 때문에 프로듀서 입장에서 문제가 된다.

#### 이벤트는 하나의 목적만 갖도록

이벤트 정의에 타입 필드를 추가해서 하위 속성을 따로 두려고 하는 것은 안티패턴이다.

이벤트는 수많은 종류의 데이터를 기록하는 일반 이벤트가 아닌 하나의 비즈니스 액션(concrete)에 관한 것이어야 한다. 다양한 타입 매개변수를 지닌 generic 이벤트가 존재한다? [bounded context](https://martinfowler.com/bliki/BoundedContext.html)가 모호하다는 것이다.

(나머지 생략)

### 이벤트 처리

[이벤트 소싱 패턴](https://learn.microsoft.com/ko-kr/azure/architecture/patterns/event-sourcing)

스트림에서 이벤트를 소싱하는 패턴에서 컨슈머 클라이언트는 새 이벤트를 폴링해서 처리하고 필요한 출력 이벤트를 내보내는 작업을 무한 반복한다.

### 확정적 스트림 처리

비즈니스 로직이 변경되거나 버그, 에러가 발생하면 재처리는 불가피하기 때문에 결과를 확정적으로 만드는 일이 중요하다.

#### 이벤트 기반 마이크로서비스의 두 가지 주된 처리 상태

- 이벤트를 실시간에 가깝게 처리
  - 보통 실행 시간이 긴(long-running) 마이크로서비스가 이렇게 처리한다.
- 과거부터 이벤트를 처리해서 현재를 따라잡는 catch-up
  - 규모가 작은 신규 서비스에서 일반적이다.

#### 워터 마크

처리 토폴로지를 흐르면서 이벤트 시간의 진행 상황을 추적하고 주어진 이벤트 시간(또는 그 이전까지) 모든 데이터가 처리 완료됬음을 선언하기 위해 사용한다.

#### 비순차 이벤트와 지각 이벤트

이벤트 스트림에서 자신의 앞에 있는 이벤트보다 타임스탬프가 더 큰 이벤트를 비순차 이벤트(out-of-order event)라고 한다.

한도 끝도 없이 업데이트 되는 이벤트 스트림과 같은 무한 데이터 세트(unbounded data set)에서는 지연과 확정성 요인을 반드시 고려해야한다.

##### 지각 판단

타임 스탬프를 이용해서 판단한다. 컨슈머가 정한 데드라인을 지키지 못하고 늦게 도착한 경우

##### 윈도잉(windowing)

윈도잉은 이벤트를 시간에 따라 그룹핑하는 것이다.

- 슬라이딩 윈도
  - 크기가 고정되어 있고 윈도 슬라이드(window slide)라는 증분 단계(incremental step)만큼 윈도가 서로 겹친다. 슬라이딩 윈도우를 활용하면 "지난 한 시간 동안 내 제품을 클릭한 사용자가 몇 명인지?"에 대한 답을 할 수 있다.

- 세션 윈도
  - 크기가 동적으로 변하는 윈도우, 활동이 없으면 타임아웃 경과 시 종료되고 그 이후 다시 활동이 재개되면 새로운 세션이 시작된다. "사용자가 주어진 브라우저 세션 동안 무엇을 보았는가?"라는 질문에 대답할 수 있다.

### 상태 저장 스트리밍

- 구체화된 상태 : 소스 이벤트 스트림의 이벤트를 투영한 것(불변)
- 상태 저장소 : 서비스가 비즌니스 상태를 저장하는 곳(가변)

상태 저장소는 내부 로컬 또는 외부 스토리지 모두 가능하다.

## 참고자료

[이벤트 기반 마이크로서비스 구축](https://www.aladin.co.kr/m/mproduct.aspx?start=short&itemid=269568979)

Chapter 1 ~ 7
