# Binary Search

## 이진 탐색 수행 과정

이진 탐색은 정렬된 데이터에서 사용할 수 있는 고속 탐색 알고리즘이다. 왜 고속인가? 탐색 범위를 절반으로 계속 줄여나가기 때문이다. 그래서 이름도 `이진`탐색이다.  
이진 탐색 과정은 아래와 같다.

1. 데이터 중앙의 요소를 찾는다.

2. 중앙의 요소와 찾는 값(target)을 비교한다.

3. 목표값이 중앙의 요소보다 작으면 탐색 범위를 중앙의 요소 기준으로 왼쪽 절반으로 이진 탐색을 수행한다. 아니라면 탐색 범위를 오른쪽 절반으로 이진 탐색을 수행한다.

4. 반복한다.

## 이진 탐색의 구현

```<C>
int BinarySearch( int arrays[], int size, int target ) {

	int left, right, mid;

	left = 0;
	right = size - 1;

	while (left <= right) {
		mid = left + (right - left) / 2;

		if (arrays[mid] == target) {
			return mid;
		}
		else if (arrays[mid] > target) {
			right = mid - 1;
		}
		else {
			left = mid + 1;
		}
	}

	// 못 찾음
	return -1;
}
```

기본적인 구현은 위와 같다. 이 때 가장 구현하기 어려운 점은 인덱스다. 특히 반복문의 종료조건이 직관적으로 느껴지지 않는다. 왜 등호가 들어가야할까?

우선 생각해볼 것이 mid = left + (right - left) / 2 를 구할 때 분자 값이 홀수라면 나머지를 버리게 된다. 즉 배열에 짝수개가 있을 때 mid는 가운데 2개의 요소 중 왼쪽을 택하게 된다는 것이다.

등호가 없을 때 어떤 일이 일어나는지 생각해보자.  
[2, 4, 6, 10, 16, 19, 22, 23, 30, 32] 에서 이분 탐색을 통해 10을 찾아보자.

반복 1:
left_idx = 0, right_idx = 9, mid_idx = 4
지금도 배열에 원소가 짝수 개라서 인덱스 4,5 중 왼쪽인 4가 mid_idx임을 확인할 수 있다.  
이제 target값인 10과 비교했을 때 mid에 위치한 값은 16이다. 따라서 범위를 절반으로 줄이고 왼쪽을 찾아야한다. right_idx이 3이된다.

반복 2:
left_idx = 0, right_idx = 3, mid_idx = 1
다시 배열이 짝수 개가 되었다. mid의 위치한 값은 4며 target보다 작기 때문에 범위를 오른쪽 절반으로 줄여야한다. left_idx는 2가된다.

반복 3:
left_idx = 2, right_idx = 3, mid_idx = 2
이제 배열에 원소 2개밖에 남지 않았다. mid에 위치한 값인 6은 target보다 작기 때문에 범위를 오른쪽 절반으로 줄여야한다. left_idx는 3이된다.  
이제 집중해야한다. left_idx와 right_idx가 같아졌다. 만약에 반복문에 등호 조건이 없다면 루프가 끝나게 된다. 즉 target은 인덱스 3에 위치하고 있는데 찾지 못하는 결과가 발생하게 된다.

결론적으로 헷갈리면 반복 3의 상태를 생각하면 된다. 원소가 2개인 배열에서 오른쪽에 target이 위치하는 경우를 생각해보자. [10, 20] target = 20
이런 극단적인 예시를 외운다면 이진 탐색을 구현할 때 루프 조건을 기억하기 쉽다.

##
